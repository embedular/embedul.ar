#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>


const struct
{
    uint32_t    freq;
    uint32_t    msel;
    uint32_t    nsel;
    uint32_t    psel;
    uint32_t    fref;
} 
PLL0_Cfg[] = 
{
    {   .freq = 63750   ,.msel = 85     ,.nsel = 8      ,.psel = 2  ,.fref = 1500000   },
    {   .freq = 63750   ,.msel = 170    ,.nsel = 16     ,.psel = 2  ,.fref = 750000    },
    {   .freq = 63750   ,.msel = 255    ,.nsel = 24     ,.psel = 2  ,.fref = 500000    },
    {   .freq = 63750   ,.msel = 340    ,.nsel = 32     ,.psel = 2  ,.fref = 375000    },
    {   .freq = 74250   ,.msel = 99     ,.nsel = 8      ,.psel = 2  ,.fref = 1500000   },
    {   .freq = 74250   ,.msel = 198    ,.nsel = 16     ,.psel = 2  ,.fref = 750000    },
    {   .freq = 74250   ,.msel = 297    ,.nsel = 24     ,.psel = 2  ,.fref = 500000    },
    {   .freq = 74250   ,.msel = 396    ,.nsel = 32     ,.psel = 2  ,.fref = 375000    },
    {   .freq = 74500   ,.msel = 149    ,.nsel = 12     ,.psel = 2  ,.fref = 1000000   },
    {   .freq = 74500   ,.msel = 298    ,.nsel = 24     ,.psel = 2  ,.fref = 500000    },    
};


#define PLL0_MSEL_MAX (1<<15)


/*
    Remark: The PLL M-divider register does not use the direct binary representations of M
    directly. Instead, it uses an encoded version MDEC of M. The valid range for M is 1 to
    2^15. This value is encoded into a 17-bit MDEC value.
    The relationship between M = msel and MDEC is expressed via the following code
    snippet. For specific examples see Section 13.8.3 and Section 13.8.4.
*/

/* multiplier: compute mdec from msel */
unsigned mdec_new (unsigned msel) 
{
    unsigned x=0x4000, im;
    switch (msel) 
    {
        case 0: return 0xFFFFFFFF;
        case 1: return 0x18003;
        case 2: return 0x10003;
        default:
        for (im = msel; im <= PLL0_MSEL_MAX; im++)
            x = ((x ^ x>>1) & 1) << 14 | x>>1 & 0xFFFF;
        return x;
    }
}


/*
    The values for SELP and SELI depend on the value for M = msel as expressed by the
    following code snippet (SELR = 0):
*/

/* bandwidth: compute seli from msel */
unsigned anadeci_new (unsigned msel) 
{
    unsigned tmp;
    if (msel > 16384) return 1;
    if (msel > 8192) return 2;
    if (msel > 2048) return 4;
    if (msel >= 501) return 8;
    if (msel >= 60) 
    {
        tmp=1024/(msel+9);
        return ( 1024 == ( tmp*(msel+9)) ) == 0 ? tmp*4 : (tmp+1)*4 ;
    }
    return (msel & 0x3c) + 4;
}


/* bandwidth: compute selp from msel */
unsigned anadecp_new (unsigned msel) 
{
    if (msel < 60) return (msel>>1) + 1;
    return 31;
}


/*
    Remark: The PLL NP-divider register does not use the direct binary representations of N
    = nsel and P = psel directly. Instead, it uses encoded versions NDEC and PDEC of N and
    P respectively.
    •The valid range for N = nsel is from 1 to 2^8. This value is encoded into a 10-bit NDEC
    value. The relationship can be expressed through the following code snippet:
*/

#define PLL0_NSEL_MAX (1<<8)


/* pre-divider: compute ndec from nsel */
unsigned ndec_new (unsigned nsel) 
{
    unsigned x=0x80, in;
    switch (nsel) 
    {
        case 0: return 0xFFFFFFFF;
        case 1: return 0x302;
        case 2: return 0x202;
        default:
            for (in = nsel; in <= PLL0_NSEL_MAX; in++)
                x = ((x ^ x>>2 ^ x>>3 ^ x>>4) & 1) << 7 | x>>1 & 0xFF;
            return x;
    }
}

/*
    •The valid range for P = psel is from 1 to 2^5. This value is encoded into a 7-bit PDEC
    value. The relationship can be expressed through the following code snippet:
*/

#define PLL0_PSEL_MAX (1<<5)

/* post-divider: compute pdec from psel */
unsigned pdec_new (unsigned psel) 
{
    unsigned x=0x10, ip;
    switch (psel) 
    {
        case 0: return 0xFFFFFFFF;
        case 1: return 0x62;
        case 2: return 0x42;
        default:
            for (ip = psel; ip <= PLL0_PSEL_MAX; ip++)
                x = ((x ^ x>>2) & 1) << 4 | x>>1 & 0x3F;
            return x;
    }
}



int main ()
{
    printf ("#pragma once\n");
    printf ("// -----------------------------------------------------------------------------\n");
    printf ("// Automatically generated by utils/lpc_pll0.c on " __DATE__ " " __TIME__ "\n");
    printf ("// -----------------------------------------------------------------------------\n\n");
    
    uint32_t cfreq = 0;
    
    for (uint32_t i = 0; i <= sizeof(PLL0_Cfg) / sizeof(PLL0_Cfg[0]); ++i)
    {
        if (cfreq != PLL0_Cfg[i].freq)
        {
            if (i)
            {
                printf ("    #else\n");
                printf ("        #error Unsupported PLL0 reference frequency (PLL0_RFREQ) for a pixel clock of %i KHz (MODELINE_PCLK_KHZ).\n", cfreq);
                printf ("    #endif\n");
            }
            
            cfreq = PLL0_Cfg[i].freq;
            
            if (i == sizeof(PLL0_Cfg) / sizeof(PLL0_Cfg[0]))
            {
                break;
            }
            
            printf (!i? "#if " : "#elif ");
            printf ("(MODELINE_PCLK_KHZ == %i)\n", PLL0_Cfg[i].freq);
            
            printf ("    #if !defined PLL0_RFREQ\n");
            printf ("        #define PLL0_RFREQ %i\n", PLL0_Cfg[i].fref);
            printf ("    #endif\n");
            
            printf ("    #if ");
        }        
        else 
        {
            printf ("    #elif ");
        }
        
        printf ("(PLL0_RFREQ == %i)\n", PLL0_Cfg[i].fref);
        printf ("        // MSEL %i, NSEL %i, PSEL %i.\n", PLL0_Cfg[i].msel, PLL0_Cfg[i].nsel, PLL0_Cfg[i].psel);
        
        unsigned mdec = mdec_new    (PLL0_Cfg[i].msel);
        unsigned selp = anadecp_new (PLL0_Cfg[i].msel);
        unsigned seli = anadeci_new (PLL0_Cfg[i].msel);
        unsigned selr = 0;
        unsigned pdec = pdec_new    (PLL0_Cfg[i].psel);
        unsigned ndec = ndec_new    (PLL0_Cfg[i].nsel);
        
        printf ("        #define PLL0_MDEC 0x%X\n", mdec);
        printf ("        #define PLL0_SELP 0x%X\n", selp);
        printf ("        #define PLL0_SELI 0x%X\n", seli);
        printf ("        #define PLL0_SELR 0x%X\n", selr);
        printf ("        #define PLL0_PDEC 0x%X\n", pdec);
        printf ("        #define PLL0_NDEC 0x%X\n", ndec);
    }
    
    printf ("#else\n");
    printf ("    #error Unsupported pixel clock frequency (MODELINE_PCLK_KHZ).\n");
    printf ("#endif\n");
    
    return 0;
}
